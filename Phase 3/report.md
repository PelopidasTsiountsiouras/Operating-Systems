# TinyShell - Phase 3 Report

## 1. Εισαγωγή

Στην **τρίτη φάση** του Tinyshell επεκτάθηκε η λειτουργικότητα του shell με την **προσθήκη μηχανισμών ελέγχου εργασιών (job control)**, όπως αυτόι συναντώνται στα σύγχρονα Unix-like shells (π.χ. `bash`, `dash`, `zsh` etc).

Ο στόχος της Phase 3 είναι η σωστή διαχείριση:
- διεργασιών προσκηνίου (foreground),
- διεργασιών παρασκηνίου (background),
- σημάτων από το τερματικό (`Ctrl-C`, `Ctrl-Z`),
- καθώς και η υλοποίηση των built-in εντολών `fg` και `bg`.

Η υλοποίηση βασίζεται αποκλειστικά σε **POSIX system calls** και μηχανισμούς διαχείρισης σημάτων.

## 2. Νέες Λειτουργίες Phase 3

### 2.1 Εκτέλεση στο Παρασκήνιο (`&`)

Υλοποιήθηκε υποστήριξη για εκτέλεση εντολών στο παρασκήνιο με τη χρήση του τελεστή `&`.

Παράδειγμα:
```sh
tsh> sleep 100 &
[1] 27121
```

Στην περίπτωση αυτή:
- το shell δεν μπλοκάρει,
- δεν καλείται `tcsetpgrp()`,
- και επιστρέφει άμεσα στο prompt.

Η διεργασία τοποθετείται σε **ξεχωριστό process group** και καταχωρείται στη λίστα εργασιών.

### 2.2 Process Groups και Έλεγχος Τερματικού

Κάθε εργασία (job) εκτελείται στο δικό της process group:

```cpp
setpgid(pid, pid);
```

Για τις foreground εργασίες το shell παραχωρεί τον έλεγχο του τερματικού με:

```cpp
tcsetpgrp(STDIN_FILENO, pgid);
```

Μετά την ολοκλήρωση ή αναστολή της εργασίας, ο έλεγχος επιστρέφει στο shell.

### 2.3 Χειρισμός Σημάτων `Ctrl-C` και `Ctrl-Z`

Το TinyShell:
- **αγνοεί** τα `SIGINT` και `SIGTSTP`,
- επιτρέποντας στα σήματα να αποστέλλονται **μόνο στο foreground process group.**

Στις child διεργασίες, τα σήματα επαναφέρονται στην προεπιλεγμένη συμπεριφορά (`SIG_DFL`).

Παράδειγμα:
```sh
tsh> sleep 100
^C
```
→ τερματίζεται μόνο η διεργασία `sleep`, όχι το shell.

```sh
tsh> sleep 100
^Z
[1]+  Stopped                 sleep 100
```
→ η εργασία μπαίνει σε κατάσταση *Stopped*.

### 2.4 Built-in Εντολές `fg` και `bg`

`fg %jobid`

- επαναφέρει μια stopped/background εργασία στο προσκήνιο,
- στέλνει `SIGCONT` στο process group,
- παραχωρεί τον έλεγχο του τερματικού,
- και περιμένει μέχρι να τερματιστεί ή να ανασταλεί.

Παράδειγμα:

```sh
tsh> fg %1
```

`bg %jobid`

- συνεχίζει μια stopped εργασία στο παρασκήνιο,
- στέλνει `SIGCONT`,
- χωρίς να δώσει έλεγχο τερματικού.

Παράδειγμα:

```sh
tsh> bg %1
[1]+ sleep 100 &
```

## 3. Διαχείριση Εργασιών (Job List)

Οι εργασίες αποθηκεύονται σε στατική δομή:

```cpp
typedef struct job {
    pid_t pid;
    pid_t pgid;
    int jid;
    job_state_t state;
    char cmdline[MAXLINE];
} job_t;
```

Κάθε εργασία έχει:

- job ID (`jid`)
- process group ID (`pgid`)
- κατάσταση (`FG`, `BG`, `ST`)

Η λίστα ενημερώνεται δυναμικά μέσω του `SIGCHLD` handler.

## 4. Χειρισμός `SIGCHLD` και Καθαρισμός Διεργασιών

Ο handler `sigchld_handler()`:

- συλλέγει όλες τις διεργασίες με `waitpid()`,
- ανιχνεύει: 
    - τερματισμό (`WIFEXITED`)
    - σήμα (`WIFSIGNALED`)
    - αναστολή (`WIFSTOPPED`)
- και αφαιρεί πλήρως τις ολοκληρωμένες διεργασίες από τη λίστα.

Αυτό εξασφαλίζει:

- καμία zombie διεργασία
- σωστή ενημέρωση της κατάστασης εργασιών

## 5. Αγνόηση Σημάτων Τερματικού (SIGTTIN / SIGTTOU)

Για να αποφευχθεί η αναστολή του shell από το kernel:

```cpp
SIGTTIN
SIGTTOU
```

αγνοούνται πλήρως.

Αυτό επιτρέπει στο TinyShell να καλεί `tcsetpgrp()` χωρίς να αναστέλλεται όταν δεν είναι foreground process group.

## 6. System Calls και Signals που Χρησιμοποιούνται

| Κλήση / Σήμα  | Ρόλος                       |
| ------------- | --------------------------- |
| `fork()`      | Δημιουργία child διεργασίας |
| `execvp()`    | Εκτέλεση εντολής            |
| `setpgid()`   | Δημιουργία process group    |
| `tcsetpgrp()` | Έλεγχος τερματικού          |
| `waitpid()`   | Παρακολούθηση διεργασιών    |
| `kill()`      | Αποστολή σημάτων            |
| `SIGINT`      | Διακοπή (`Ctrl-C`)          |
| `SIGTSTP`     | Αναστολή (`Ctrl-Z`)         |
| `SIGCONT`     | Συνέχιση εργασίας           |
| `SIGCHLD`     | Ενημέρωση τερματισμού child |

## 7. Έλεγχος Ορθής Λειτουργίας

Τα παρακάτω tests επιβεβαιώνουν τη σωστή λειτουργία:

- foreground execution (`sleep 1`)
- background execution (`sleep 1 &`)
- Ctrl-C → τερματισμός job
- Ctrl-Z → αναστολή job
- `bg %N` → συνέχιση στο παρασκήνιο
- `fg %N` → επιστροφή στο προσκήνιο
- έλεγχος με `ps` → κανένα zombie process

Η συμπεριφορά είναι ισοδύναμη με αυτή του `bash`.

## 8. Συμπεράσματα

Με την ολοκλήρωση της Phase 3, το TinyShell:

- υποστηρίζει πλήρη job control,
- διαχειρίζεται σωστά process groups και signals,
- αποφεύγει zombie διεργασίες,
- και ακολουθεί πιστά το POSIX μοντέλο διαχείρισης διεργασιών.

Το έργο πλέον προσεγγίζει τη συμπεριφορά ενός πραγματικού Unix shell, παραμένοντας απλό, καθαρό και ιδιαίτερα εκπαιδευτικό.

## 9. Τελική Αξιολόγηση

Η υλοποίηση της Phase 3 ολοκληρώνει επιτυχώς όλες τις απαιτήσεις του TinyShell, συνδυάζοντας:

- σταθερότητα,
- σωστή χρήση system calls,
- και καθαρό σχεδιασμό.

Το TinyShell αποτελεί ένα πλήρως λειτουργικό εκπαιδευτικό παράδειγμα Unix-like κελύφους.